### 第一章：前端工程化主要解决的问题

- 传统语言或语法的弊端；
- 无法使用模块化 / 组件化；
- 重复的机械工作；
- 代码风格统一、质量保证；
- 依赖后端服务接口支持；
- 整体依赖后端项目；

![image-20211222103124740](../../../Library/Application%20Support/typora-user-images/image-20211222103124740.png)

前端工程化的内容概况：

- 脚手架工具开发；
- 自动化构建系统；
- 模块化打包；
- 项目代码规范化；
- 自动化部署；

### 第二章：脚手架工具开发

- 概要：

  - 相同的组织结构；
  - 相同的开发范式；
  - 相同的模块依赖；
  - 相同的工具配置；
  - 相同的基础代码；

- 脚手架工具的作用：

  - 

- 常用的脚手架工具：

  - React 项目 --> create-react-app；
  - Vue 项目 --> vue-cli;
  - Angular 项目 --> angular-cli;
  - Yeoman （通用型脚手架工具）灵活、易扩展；
  - Plop （创建特定类型的文件，例如创建一个组件 / 模块所需要的文件）

- 通用脚手架工具剖析：

  - Yeoman （通用型脚手架工具）灵活、易扩展

  ![image-20211222112153794](../../../Library/Application%20Support/typora-user-images/image-20211222112153794.png)

  - Yeoman 常规使用步骤：

    1. 明确需求；
    2. 找到合适的 Generator；
    3. 全局范围安装找到的 Generator；
    4. 通过 Yo 运行对应的 Generator；
    5. 通过命令行交互填写选项；
    6. 生成所需要的项目结构；

    - 自定义 Generator：

      1. Generator 基本结构：

      <img src="../../../Library/Application%20Support/typora-user-images/image-20211222113429806.png" alt="image-20211222113429806" style="zoom:50%;" />

      ![image-20211222113619776](../../../Library/Application%20Support/typora-user-images/image-20211222113619776.png)

      2. Generator 模块名称：

         必须是：generator-<name>

      3. 根据模版创建文件：（提升文件创建的效率）

      4. 发布 Generator：

         1. 创建 generator 模块，
         2. 创建 git 仓库；
         3. 推送到远程 GitHub，
         4. 通过 npm publish 或 yarn publish 发布到 npm 仓库；
         5. 使用：
            1. 可以通过 npm 或 yarn 下载使用 yeoman 

  - npm 镜像加速源：

  ![image-20211222113108322](../../../Library/Application%20Support/typora-user-images/image-20211222113108322.png)

- 开发一款脚手架：

- Plop 小而美的脚手架工具：

  - 提高创建重复文件的效率

  ![image-20211222150309526](../../../Library/Application%20Support/typora-user-images/image-20211222150309526.png)

  - 使用 Plop 的步骤：
    1. 将 plop 模块作为项目开发依赖安装；
    2. 在项目根目录下创建一个 plopfile.js 文件；
    3. 在 plopfile.js 文件中定义脚手架任务；
    4. 编写用于生成特定类型文件的模版；（plop-templates / xxx.hbs）
    5. 通过 plop 提供的 cli 运行脚手架任务；
       - yarn plop xxx（生成器任务名）

- CLI 脚手架：

  ```javascript
  // Node CLI 应用入口文件必须要有这样的文件头
  // 如果 Linux 或者 macOS 系统下还需要修改此文件的读写权限为 755
  // 具体就是通过 chmod 755 cli.js 实现修改；
  
  /**
   * 脚手架的工作过程：
   * 1.通过命令行交互询问用户问题
   * 2.根据用户回答的结果生成文件
  */
  
  const fs = require('fs')
  const path = require('path')
  const inquirer = require('inquirer')
  const ejs = require('ejs')
  
  inquirer.prompt([
      {
          type:'input',
          name:'name',
          message: 'Project name ?'
      }
  ])
  .then(anwsers =>{
      // 根据用户回答的结果生成文件
      // 模版目录
      const templDir = path.join(__dirname, 'templates')
      // 目标目录
      const destDir = process.cwd()
      // 将模版目录下的文件全转换到目标目录
      fs.readFile(templDir, (err, files) => {
          if(err) throw err
          files.forEach(file => {
              ejs.readFile(path.join(templDir, file), anwsers, (err, result) => {
                  if(err) throw err
                  // 将结果写入目标文件路径中
                  fs.writeFileSync(path.join(destDir, file), result)
              })
          })
      })
  })
  ```

### 第三章：自动化构建系统

![image-20211222154727137](../../../Library/Application%20Support/typora-user-images/image-20211222154727137.png)

- 自动化构建的作用：

  1. 脱离运行环境兼容带来的问题；
  2. 在开发阶段，使用提高效率的语法、规范和标准；

- NPM Script 方式，包装构建命令：

  ![image-20211222155459888](../../../Library/Application%20Support/typora-user-images/image-20211222155459888.png)

  - “build”：“sass  sass/main.scss  css/style.css  --watch” 

  - “preserve ”：“yarn build”  //  启动本地服务器前自动先构建（build）一下

  - “serve”：“browser-sync  .  --files  \"css/*.css\ ”  // 本地静态服web务器

    --files：监听项目下文件的变化，而实时同步更新浏览器中的变化效果，更改完成后避免手动刷新浏览器。

  - “start”：“run-p build serve” // 同时构建后启动静态服务且实时监听文件变化

- 常用的构建工具：

  - Grunt：

    - 工作过程是基于临时文件去实现的，所以构建速度相对较慢；
    - 先编译 => 自动添加私有属性前缀 => 压缩代码；（消耗磁盘读写操作）
    - return flase // 标记失败任务，且后面的任务不在执行；
    - grunt 插件使用：
      1. 通过 npm 安装插件；
      2. 再到 gruntfile.js 中载入插件；（grunt.loadNpmTasks(‘grunt-contrib-clean’)）
      3. 根据插件的文档，完成配置选项；（grunt.initConfig()）
      4. *grunt-contrib-watch* 插件：文件修改完后自动编译

  - Gulp：

    - 基于内存实现的，文件处理环节都是在内存中实现的；相对磁盘读写快了很多；

    - 默认支持同时执行多个任务；

    - 基本使用：

      - 导出函数的方式实现 gulp 任务

      ```javascript
      exprots.foo = done => {
        console.log('foo task working')
        done() // 标识任务结束
      }
      // 默认任务
      exports.default = done => {
        console.log('default task working')
        done() // 标识任务结束
      }
      ```

      - 4.0 之前的版本

      ```javascript
      const gulp = require('gulp')
      gulp.task('bar', done => {
        console.log('bar task working')
        done() // 标识任务结束
      })
      ```

    - 组合任务 API：

      - series ：串行任务
      - parallel ：并行任务

    - 异步任务的三种方式：

      1. 通过回调的函数的方式（callback）；
      2. promise 方式；需要return Promise 对象；
      3. async / await 函数方式；

    ![gulp构建过程核心工作原理](../../../Library/Application%20Support/typora-user-images/image-20211223100456131.png)

    - 封装自动化构建工作流：

    ![image-20211223142845089](../../../Library/Application%20Support/typora-user-images/image-20211223142845089.png)

    1. 创建自定义 gulp 模块；
    2. 将模块发布到 npm 仓库；
    3. 在项目中使用创建的模块；

  - FIS：（百度前端团队推出的构建系统）

    - 更像是捆绑，典型的需求集成在内部；
    - 资源加载
    - 模块化开发
    - 代码部署
    - 性能优化

### 第四章：模块化打包

- 模块化的演变过程

  - Stage1 => 文件划分方式；

    缺点：

    1. 污染全局作用域；
    2. 命令冲突问题；
    3. 无法管理模块依赖关系；

  - Stage2 => 命令空间方式；

    优点：

    1. 减小命令冲突问题；

    缺点：

    1. 没有私有化，私有空间；
    2. 无法管理模块依赖关系；

  - Stage3 => IIFE（立即执行函数）；

    优点：

    1. 私有作用域，暴露一个全局对象；
    2. 自执行函数的参数作为依赖声明，依赖关系明确了；

    缺点：

    1. 闭包的私有成员难以得到释放；内存占用；

- 模块化规范

  - node端：CommonJS 规范：**<font color = 'red'>是以同步模式加载模块</font>**

    1. 每一个文件就是一个模块；
    2. 每个文件都有单独的作用域；
    3. 通过 module-expert 导出成员；
    4. 通过 require 函数载入模块；

  - 浏览器端：

    1. Require.js：（AMD [Asynchronous Module Definition]）异步定义模块规范（依赖前置）

       定义模块：

    ![image-20211227173319521](../../../Library/Application%20Support/typora-user-images/image-20211227173319521.png)

    ​	  加载模块：

    ![image-20211227173549644](../../../Library/Application%20Support/typora-user-images/image-20211227173549644.png)

    2. Sea.js：（CMD [Common Module Definition]）（依赖后置-在callback中 require 载入）

    ![image-20211227173836455](../../../Library/Application%20Support/typora-user-images/image-20211227173836455.png)

  - 现阶段统一两种规范：

    - 浏览器端：（ESModule）
      - 
    - node 端：（CommonJS）
      - 

- 常用模块化打包工具

- 基于模块化工具构建现代web应用

- 打包工具的优化技巧

### 第五章：项目代码规范化



### 第六章：自动化部署



### 其他

- node cli 程序的权限问题（Linux）![image-20211227112248217](../../../Library/Application%20Support/typora-user-images/image-20211227112248217.png)
- chmod 755 cli.js； chmod +x cli.js；
