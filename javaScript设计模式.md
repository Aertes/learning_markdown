## JavaScript 设计模式

### 第一章：什么是设计模式

- 一个模式就是一个可重复的方案，可应用于在软件设计中的常见问题；

- 模式的另一种解释就是一个我们如何解决问题的模版，那些可以在许多不同的情况里使用的模版；

设计模式有一下三点好处：

1. **模式是行之有效的解决方法**：他们提供固定的解决方法来解决在软件开发中出现的问题，这些都是久经考验的反应了开发者的经验和见解的使用模式来定义的技术；
2. **模式可以很容易重用**：一个模式通常反映了一个可以适应自己需要的开箱即用的解决方案。这个特性让它们很健壮；
3. **模式善于表达**：当我们看到一个提供某种解决方案的模式时，一般有一组结构和词汇可以非常优雅地帮助表达相当大的解决方案；

设计模式必须提供的其他的一些优势：

1. 模式的重用可以帮助防止在应用程序开发过程中出现的一些可能导致重大问题的小问题。这意味着当代码是建立在行之有效的模式上时，我们可以花更少的时间去关心我们的代码结构，从而能花更多的时间关注我们的解决方案的整体质量。这是因为模式可以鼓励我们在更好的结构化和有组织的方式下编码，这将避免在未来由于清洁的目的而去重构它。
2. 模式可以提供一个不需要绑定到一个特定问题的书面的概括性的解决方案。这个广义的方法意味着不用管我们正在处理的应用程序 (许多情况下的编程语言) 设计模式的应用可以提高我们的代码的结构。
3. 某些模式可以通过避免重复来减小我们代码的文件大小。通过鼓励开发者更仔细地看待他们的解决方案来减少重复的地方，如通过将类似的执行流程作为一个一般性的函数来减少函数的数量，这样我们就可以减小代码库的总体大小，这也成为使代码更DRY。
4. 模式增加了开发者的词汇（提供的API），这使得交流更快速。
5. 经常使用的模式可通过收集其他使用这些模式的开发人员贡献给设计模式社区的经验来改进。在某些情况下，这将导致全新模式的创建，同时也可以提供改进的指导大家如何使用特定的模式才是最好的。这可以确保基于模式的解决方案继续变得比特别的解决方案更健壮。 

### 第二章：JavaScript 设计模式的结构

你可能会对设计模式的作者如何接近勾勒出概念轮廓，实施和新模式的目的。模式是最出提出的一种在两者之间建立关系的**规则**：

- 上下文环境；
- 在这种环境下产生的系统力量；
- 一类配置，考虑到允许这种力量在自己的上下文环境中解决这一点，现在让我们对一种设计模式的组件元素，一探究竟。
- 一种设计模式应该具有：
  1. 上下文概述：在设计模式中的上下文对响应用户需求是很有效的；
  2. 问题声明：一类问题的声明，能让我们理解模式的意图；
  3. 解决方案：在可理解的列表和看法上，对用户的问题如何解决的一种描述；
  4. 设计：模式设计，特别是与之交互的用户行为的描述；
  5. 实现：对模式如何被实现的一种指引；
  6. 例证：在模式中的一种类的虚拟化表示；
  7. 例子：模式实现的一种最下的形式；
  8. 共同条件：可能会有其他的什么模式会被用到，以对被描述的模式进行支持；
  9. 关系：与该模式相似的模式；
  10. 已知的使用：模式有没有被正常使用；
  11. 讨论：获利的模式的想法团队或者作者的沟通讨论；

### 第三章：JavaScript 编写设计模式

创建新设计模式的建议：

- **模式是否实用**：确保这个模式能够对一些常见的问题有明确的解决方案，而不是临时的解决方案。
- **保持最佳实践**：我们的设计需要以最佳实践中所获得的理解作为基础；
- **设计模式对用户来说应该是清晰的**：设计模式必须对任何形式的用户体验都是清晰的。因为设计模式主要服务于开发者们，所以不能强迫他们去改变原来的行为，那样的开发者们才会去使用这个模式；
- **独创力不是设计模式的关键**：当我们在设计一个模式的时候，我们既不需要是发明者，也不需要去担心是否是其他模式的子集。如果某个想法有很强的实用性，那么这就是一个创造新模式的机会。
- **需要有几个有说服力的例子**：一个好的设计模式需要有一个有说服力的例子来展示这个模式是成功的。为了广泛使用这个设计模式，这些例子需要展示良好的设计原则。

### 第四章：JavaScript 反模式

反模式的两种观念：

- 描述对于一个特殊的问题，提出了一个*糟糕的*解决方案，最终导致一个坏结果发生；
- 描述如何摆脱上述解决方案并能提出一个好的解决方案；

javascript 的反模式例子如下：

- 在全局上面文中定义大量污染全局命名空间的变量；
- 在调用 **setTimeout** 和 **setInterval** 时传递字符串（会用 eval 来执行）而不是函数；
- 修改 **Object** 的原型（这是最糟糕的反模式）；
- 使用內联 javascript ；
- 在本应使用 document.createElement 的地方使用 document.write ；document.write 被错误的用了相当多的年头，它有相当多的缺点，包括如果在页面加载后执行它可能会覆盖我们的页面。再有它不能工作在XHTML下，这也是另外一个我们使用像 document.createElement 这种对DOM友好方法的原因。

### 第五章：JavaScript 设计模式的分类

1. 创建型设计模式：

   创建型设计模式关注于对象创建的机制方法；通过该方法，对象以适应工作环境的方式被创建。基本的对象创建方法可能会给项目增加额外的复杂性，而这些模式的目的就是为了通过控制创建过程解决这个问题；

   - **构造器模式**（Constructor）
   - **工厂模式**（Factory）
   - **抽象工厂模式**（Abstract）
   - **原型模式**（Prototype）
   - **单例模式**（Singleton）
   - **建造者模式**（Builder）

2. 结构型设计模式：

   结构模式关注于对象组成和通常识别的方式实现不同对象之间的关系。该模式有助于在系统的某一部分发生改变的时候，整个系统结构不需要改变。该模式同样有助于系统中某个部分没有达到某一目的的部分进行重组；

   - **装饰模式**
   - **外观模式**
   - **享元模式**
   - **适配器模式**
   - **代理模式**

1. 行为型设计模式：

   行为模式关注改善或精简在系统中不同对象间通信；

   - **迭代模式**
   - **中介者模式**
   - **观察者模式**
   - **访问者模式**

### 第六章：JavaScript 设计模式分类概览表

| SN（设计模式）                    | 描述                                                         |
| :-------------------------------- | :----------------------------------------------------------- |
| Creational                        | 根据创建对象的概念分成下面几类：                             |
| Calss                             |                                                              |
| Factory Method（工厂方法）        | 通过将数据和事件接口化来构建若干个子类。                     |
| Object                            |                                                              |
| Abstract Factory（抽象工厂）      | 建立若干族类的一个实例，这个实例不需要具体类的细节信息。（抽象类） |
| Builder（建造者）                 | 将对象的构建方法和其表现形式分离开来，总是构建相同类型的对象。 |
| Prototype（原型）                 | 一个完全初始化的实例，用于拷贝或者克隆。                     |
| Singleton（单例）                 | 一个类只有唯一的一个实例，这个实例在整个程序中有一个全局的访问点。 |
|                                   |                                                              |
| Structural                        | 根据构建对象块的方法分成下面几类：                           |
| Class                             |                                                              |
| Adapter（适配器）                 | 将不同类的接口进行匹配，调整，这样尽管内部接口不兼容但是不同的类还是可以协同工作的。 |
| Bridge（桥接模式）                | 将对象的接口从其实现中分离出来，这样对象的实现和接口可以独立的变化。 |
| Composite（组合模式）             | 通过将简单可组合的对象组合起来，构成一个完整的对象，这个对象的能力将会超过这些组成部分的能力的总和，即会有新的能力产生。 |
| Decorator（装饰器）               | 动态给对象增加一些可替换的处理流程。                         |
| Facada（外观模式）                | 一个类隐藏了内部子系统的复杂度，只暴露出一些简单的接口。     |
| Flyweight（享元模式）             | 一个细粒度对象，用于将包含在其它地方的信息在不同对象之间高效的共享。 |
| Proxy（代理模式）                 | 一个充当占位符的对象用来代表一个真实的对象。                 |
|                                   |                                                              |
| Behavioral                        | 基于对象间作用方式来分类：                                   |
| Class                             |                                                              |
| Interpreter（解释器）             | 将语言元素包含在一个应用中的一种方式，用于匹配目标语言的语法。 |
| Template Method（模版方法）       | 在一个方法中为某个建立一层外壳，将算法的具体步骤交付给子类去做。 |
| Object                            |                                                              |
| Chain of Responsibility（响应链） | 一种将请求在一串对象中传递的方式，寻找可以处理这个请求的对象。 |
| Command（命令）                   | 封装命令请求为一个对象，从而使记录日志，队列缓存请求，未处理请求进行错误处理 这些功能称为可能。 |
| Iterator（迭代器）                | 在不需要直到集合内部工作原理的情况下，顺序访问一个集合里面的元素。 |
| Mediator（中介者模式）            | 在类之间定义简化的通信方式，用于避免类之间显式的持有彼此的引用。 |
| Observer（观察者模式）            | 用于将变化通知给多个类的方式，可以保证类之间的一致性。       |
| State（状态）                     | 当对象状态改变时，改变对象的行为。                           |
| Strategy（策略）                  | 将算法封装在类中，将选择和实现分离开来。                     |
| Visitor（访问者）                 | 为类增加新的操作而不改变类本身。                             |

### 第七章：JavaScript 构造器模式











